---
title: "ST_4_ordination"
author: "Sean Swift"
date: "February 6, 2020"
output: 
  html_document:
        toc: true
        toc_depth: 4
        number_sections: true

---

# Description
ST_ordination focuses on plots related to ordination based on community dissimilarity.
Ordination plots are accompanied by heat maps, when possible.
These ordinations often require data transformation, so there's some of that too. 
Mostly using package phyloseq. Also using speedyseq when available.

TODO: 

  * Re-do ordinations with unifrac. To get tree and re-calculate, will need to re-pipeline the data.
  * Make heatmaps
  * Other types of ordination?
  * Mantel test
  * pull out the bugs responsible for each of the strong spatial gradients (this is just anecdotal at this point). 
  * make similar plots to those in ST_model with the subset axis 1 nmds values (probably within each sample type). Visualize bugs that have the strongest slopes and most significant slopes with NMDS Axis 1, which will be the “drivers” of that aspect of the ordination in each case.


# Setup
## Import data and create phyloseq object
Reading in data


```{r setup}
library(phyloseq)
library(viridisLite)
library(speedyseq)
library(ggplot2)
library(dplyr)


source("src/make_phyloseq.R")
ST_16S <- readRDS("data/processed/cleaned/ST_16S_spatial.rds")

# make phyloseq object
ST_16S_phy  <- make_phyloseq(ST_16S)
ST_16S_phy  <- subset_samples(ST_16S_phy, sample_type != "PlantShoot")

# summit water had duplicate filters, discard one set

ST_16S_phy  <- subset_samples(ST_16S_phy, !(sample_barcode %in% c(2281, 2273, 2265,2257,2249,2241,2233, 2225, 2217)))


# set seed

set.seed(100)

```


## Read in unifrac distances
Distances are saved as a lower triangular matrix.
Need to import, arrange, mirror, and convert to distance matrix.

```{r import_unifrac}
# Read in unifrac distances
x <- scan("data/raw/sequence/all_unifrac_100.unweighted.dist")
x <- x[-1]

# make empty matrix
m <- matrix(NA, 474,474)

# fill lower triangle
m[upper.tri(m, diag = F)] <- x

# pull out sample names
samp_names <- m[1,2:ncol(m)] %>% as.integer()

# delete from matrix
m <- m[-1,-1]

# add diagonal 
diag(m) <- signif(0.00, digits =4)

# fill out matrix
makeSymm <- function(m) {
   m[lower.tri(m)] <- t(m)[lower.tri(m)]
   return(m)
}
m <- makeSymm(m)

# add sample names back in
colnames(m) <- samp_names
row.names(m) <- samp_names

rm(x)

# function for subsetting the distance matrix
get_unifrac <- function(physeq, unifrac_matrix = m){
  # subsets unifrac matrix columns and rows by set of ids
  ids <- sample_names(physeq)
  if( ! ( all ( ids %in% colnames( unifrac_matrix )))){
    warning("Not all ids are in the distance matrix")
    print(ids[! ( ids %in% colnames(unifrac_matrix) ) ])
  } else {
  dist <- as.dist(unifrac_matrix[ids,ids])
  return(dist)
  }
}



```

## Set up ggplot
```{r ggplot}
theme_set(theme_bw())

pal_d = "Dark2"
scale_colour_discrete <-  function(palname=pal_d, ...){
  scale_colour_brewer(palette=palname, ...)
}
scale_fill_discrete <-  function(palname=pal_d, ...){
    scale_fill_brewer(palette=palname, ...)
}

pal_c = "C"

uniform_gradient_color <- function(palname = pal_c){
  scale_color_viridis_c(option = palname)
}

# Can change these settings with viridis package
# With colour brewer, need add a line to each plot for continuous colors
# "scale_color_gradient2(low = "green", mid = "blue", high = "red")"

#  scale_colour_continuous <-  function(palname=pal_c, ...){
#    scale_colour_brewer(palette=palname, ...)
#  }
# # 
#  scale_fill_continuous <-  function(palname=pal_c, ...){
#    scale_fill_brewer(palette=palname, ...)
#  }

```


# NMDS

## Do some broad strokes ordination

### All Samples
To start, NMDS of all samples, all OTUs (no additional filtering), Unifrac dissimilarity. 

```{r allNMDS, echo = F, message=F, results='hide'}
# It's faster to save and read in the ordination object
# To generate Unifrac ordination run the following: 

ST.uni <- get_unifrac(ST_16S_phy)

ST.ord <- ordinate(ST_16S_phy, "NMDS", ST.uni)
#saveRDS(ST.ord,"data/interim/ST.ord.rds")

# To generate Unifrac ordination run the following

#ST.ord <- ordinate(ST_16S_phy)



#### by habitat

p <- plot_ordination(ST_16S_phy, ST.ord, type="samples", color = "habitat", shape = "host")
p <- p + scale_shape_discrete(solid = T)
p

# write to pdf
ggsave("outputs/figures/all_samples_habitat_nmds.png")

#### by transect

p <- plot_ordination(ST_16S_phy, ST.ord, type="samples", color = "site_order", shape = "host")
p <- p + scale_shape_discrete(solid = T) + uniform_gradient_color()

print(p)

# write to pdf
ggsave("outputs/figures/all_samples_nmds.png")

rm(ST.ord)
```


### Just Host Associated
```{r}
ST  <- subset_samples(ST_16S_phy, host != "Nonhost")
ST  <- prune_taxa(taxa_sums(ST) > 0, ST)



# ordinate
ST.uni <- get_unifrac(ST)
ST.ord <- ordinate(ST, "NMDS", ST.uni)

# by sample
p = plot_ordination(ST, ST.ord, type="samples", color = "habitat", shape = "host", title="NMDS, Unifrac, Transect Samples, All OTUs")
p + scale_shape_discrete(solid = T) 
```


### Transect Samples
Take a closer look at transect samples (no marine samples).


```{r transectNMDS, echo = F, message=F, results='hide'}
# transform to relative abundance
#ST_rel <-transform_sample_counts(ST_16S_phy, function(x) x / sum(x) )


# subset to just transect samples
ST  <- subset_samples(ST_16S_phy, habitat != "Marine")
ST  <- prune_taxa(taxa_sums(ST) > 0, ST)

# get unifrac distances

ST.uni <- get_unifrac(ST)

# write out for craig

  # write.csv(ST@otu_table,"outputs/transects_data/ST_transects_esv_table.csv")
  # write.csv(ST@sam_data, "outputs/transects_data/ST_transects_sample_table.csv")
  # write.csv(ST@tax_table, "outputs/transects_data/ST_transects_taxonomy_table.csv")
  # write.csv(as.data.frame(as.matrix(ST.uni)), "outputs/transects_data/ST_transects_unweighted_unifrac.csv")


#################################################################
## ST is the phyloseq object containing just transect samples! ##
#################################################################

# remove full dataset
rm(ST_16S_phy)

# ordinate

ST.ord <- ordinate(ST, "NMDS", ST.uni)

# by sample
p = plot_ordination(ST, ST.ord, type="samples", color = "sample_type", shape = "host", title="NMDS, Unifrac, Transect Samples, All OTUs")
p + scale_shape_discrete(solid = T) 

# by transect
p = plot_ordination(ST, ST.ord, type="samples", color = "transect_name", shape = "host", title="NMDS, Unifrac, Transect Samples, All OTUs")
p + scale_shape_discrete(solid = T) 

rm(ST.ord)
rm(ST.uni)
```
#### Separate Ordinations By Host Type

```{r hostNMDS, echo = F, message=F, results='hide'}
# loop through and ordinate all host types

host_types <- unique(ST@sam_data$host)
for ( type in host_types ){
  # subset and ordinate
  ST_sub <- subset_samples(ST, host == type)
  ST.uni <- get_unifrac(ST_sub)
  ST.ord <- invisible(ordinate(ST_sub, "NMDS", "bray"))
  
  #plot
  p <- plot_ordination(ST_sub, ST.ord, type="samples", color = "shore_dist", shape = "sample_type", title= paste("NMDS, Unifrac,",type))
  p <- p +
    uniform_gradient_color() +
    scale_shape_discrete(solid = T)
    
  print(p)
}


```

#### Separate Ordinations By Sample Type
Based on the previous ordinations, we can see strong separation between habitats (marine, terrestrial, stream) and hosts (plants, animals, environment). 

There also appears to be a strong gradient along the transect for enviromnental samples. For animals, this trend is not very apparent.

Ordinating each sample type separately removes sample type as a source of community variation in the plot.
Separation along the transect gradient becomes much more obvious for the environmental sample types as well as plant roots.


For terrestrial environmental samples (soils and plant roots), correlation between NMDS1 and the gradeint is extremely linear along the transect gradient. For the stream samples (water and sediment), the relationship is relatively linear, with extreme values near to shore. Possibly, there is a salient gradient in the near shore estuary driving more extreme community changes for stream sample types. 


Drosophila shows a significant, but weaker trend (both in slope and model fit). 
Mosquitoes (non-blooded females) show no trend along the gradient. 

Maybe for drosophila, the effects of homeostasis and strictly herbivorous diet result in the weaker trend.
Mosquitoes are also plant feeders and were sorted to ensure only non-blooded females were collected.


```{r samplesNMDS, echo = F, message=F, results='hide'}

# loop through and ordinate each sample types

sample_types <- unique(ST@sam_data$sample_type)

for ( i in sample_types ){
  # subset and ordinate
  ST_sub <- subset_samples(ST, sample_type == i)
  ST.uni <- get_unifrac(ST_sub)
  ST.ord <- ordinate(ST_sub, "NMDS", ST.uni)
  
  # pull out MDS1, MDS2, sample type
  MDS <- as.data.frame(ST.ord$points)
  # test for significant relationship
  mod1  <- lm(MDS$MDS1 ~ ST_sub@sam_data$shore_dist)
  r_sq  <- summary(mod1)$r.squared
  p_val <- signif(summary(mod1)$coefficients[2,4], digits = 3)

 # plot MDS1 against shore_dist
  
  # set up dataframe for ggplot scatterplot
   MDS_cor<-data.frame(shore_dist = ST_sub@sam_data$shore_dist, MDS1 = MDS$MDS1)
 
  # ggplot scatterplot and regression line
  
   p <-ggplot(MDS_cor,  aes(shore_dist, MDS1, color = shore_dist)) +
     geom_point(size = 4) +
  #   labs(caption = paste("R^2 = ", round(r_sq, 3), "p =", p_val),
   #  title = i) +
     theme(
     title = element_text(size = 25, face = "bold"),
     axis.text.y = element_text(size = 25, face = "bold"),
     axis.text.x = element_blank(),
     legend.text = element_text(size = 20)
     ) +
     labs(color = "Gradient Distance", x = "Gradient Distance", y = "") +
     coord_flip() +
     uniform_gradient_color()
  
  # if low p value, plot regression line
  
  if(  p_val <0.01  ){
    
    # if regression is positive, flip the plot, regresssion line, colors
    
    if(mod1$coefficients[2] < 0 ){
      
    p <- p+ geom_abline(slope = mod1$coefficients[2]*-1, intercept = mod1$coefficients[1]*-1) +
      scale_y_reverse() 
      
    } 
    
    # if regression is negative, just add the regression line
    else
      {
    p <- p + geom_abline(slope = mod1$coefficients[2], intercept = mod1$coefficients[1])
    }
  } 

  print(p)
  
  ggsave(paste("outputs/figures/mds_cor_" , i , ".png", sep = ""), width = 12, height = 7)

  
  # rest
  Sys.sleep(0.5)
  
# plot ordination
  

  p <- plot_ordination(ST_sub, ST.ord, type="samples", color = "shore_dist", title= i)
  p <- p +
    geom_point(size = 4)+
    uniform_gradient_color() + 
    scale_shape_discrete(solid = T)+
    theme(title = element_text(size = 16, face = "bold"), axis.text=element_text(size=12),legend.text = element_text(size = 20))+
    labs(color = "Gradient Distance")
  print(p)
  
  png(paste("outputs/figures/nmds_" , i , ".png", sep = ""), width = 800, height = 600)
  print(p)
  dev.off()
}




```





### Ordinate for each transect for a given host
This turned out to not be very informative. 
The goal was to see if NMDS pulled out smaller scale spatial patterns.
Problem is, there are not many data points in each transect.


```{r}
# ST_nonhost  <- subset_samples(ST, sample_type %in% c("SoilDeep","SoilShallow","PlantRoot"))
# transect_names <- unique(ST@sam_data$transect_name) %>% as.character()
# 
# # TODO figure out how to assign unique color scales to each plot in loop
# ## Loop through 
# for ( trans in transect_names ){
#   # subset and ordinate
#   ST_sub <- subset_samples(ST_nonhost, transect_name == trans)
#   ST.uni <- get_unifrac(ST_sub)
#   min_dist <- min(ST_sub@sam_data$shore_dist)
#   max_dist <- max(ST_sub@sam_data$shore_dist)
#   ST.ord <- ordinate(ST_sub, "NMDS", ST.uni)
#   
#   #plot
#   p <- plot_ordination(ST_sub, ST.ord, type="samples", color = "shore_dist", shape = "sample_type", title= paste("Nonhost, NMDS, Unifrac,",trans))
#   p <- p  + 
#     scale_shape_discrete(solid=T)
#   print(p)
# 
# }
```



### Ordinate all soil like samples
Bacterial communities in soil (deep), soil (shallow), and plant roots all follow an apparently linear trend along the transect gradient. Differences in deep/shallow soil are not detected by ordiation and are fairly intermixed.
However, plant root communities separate out while following the same gradient trend.

```{r}
ST_soil  <- subset_samples(ST, sample_type %in% c("SoilDeep","SoilShallow","PlantRoot","Sediment"))
  ST.uni <- get_unifrac(ST_soil)
  ST.ord <- ordinate(ST_soil, "NMDS", "bray")
  
  # nmds plot shore_dist
   
  p <- plot_ordination(ST_soil, ST.ord, type="samples", color = "shore_dist", shape = "host")
  p <- p  + 
    scale_shape_discrete(solid=T)+
    uniform_gradient_color() +
    theme(title = element_text(size = 16, face = "bold"), axis.text=element_text(size=12),legend.text = element_text(size = 20))+
    geom_point(size = 3)+
    coord_fixed()+
    labs(shape = "Host Type", color = "Gradient Distance")
  print(p)
  
  # write out
  ggsave("outputs/figures/soils_etc_dist_nmds.png", width = 10, height = 10)
   
  # nmds plot host
   p <- plot_ordination(ST_soil, ST.ord, type="samples", color = "sample_type", shape = "host")
    p <- p  + 
      scale_shape_discrete(solid=T)+
      theme(title = element_text(size = 16, face = "bold"), axis.text=element_text(size=12),legend.text = element_text(size = 20))+
      geom_point(size = 3)+
      coord_fixed()+
      labs(color = "Gradient Distance", shape = "Host Type")
    print(p)
    
   # write out
  ggsave("outputs/figures/soils_etc_host_nmds.png", width = 10, height = 10)

    
    
   # corelation plot
   
  MDS <- as.data.frame(ST.ord$points)
  colnames(MDS) <- c("NMDS1","NMDS2")
  # test for significant relationship
  mod1  <- lm(MDS$NMDS1 ~ ST_soil@sam_data$shore_dist)
  r_sq  <- summary(mod1)$r.squared
  p_val <- signif(summary(mod1)$coefficients[2,4], digits = 3)
  
  MDS_cor<-data.frame(shore_dist = ST_soil@sam_data$shore_dist, NMDS1 = MDS$NMDS1)


  
  
 # Cor plot shore_dist and NMDS1
  p <- ggplot(MDS_cor,  aes(shore_dist, NMDS1, color = shore_dist)) +
    geom_point(size=3) +
      uniform_gradient_color() +  # Flipping the colors to match single sample NMDS plots :/
    labs(caption = paste("R^2 = ", round(r_sq, 3), "p =", p_val),
         x = "Gradient Distance",
         color = "Gradient Distance") +
    theme(title = element_text(size = 16, face = "bold"),
          axis.text.y = element_text(size = 25, face = "bold"),
          legend.text = element_text(size = 20),
          axis.text.x = element_blank(),
          plot.caption = element_text(size = 20)) +
    geom_abline(slope = mod1$coefficients[2], intercept = mod1$coefficients[1])+
    coord_flip()
  
 

  print(p)
  
  ggsave("outputs/figures/soils_etc_cor.png", width = 10, height = 7)


  
  rm(ST_soil)

```

### Ordinate just the middle sites
Seems like the separation along the transect gradient is driven by the extremes (Summit and Estuary).
Ordinations of the middle sites don't really separate out so neatly. 

```{r}
ST_mid  <- subset_samples(ST, (transect_name %in% c("STDrumRoadMauka","STFalls","STAboveFalls","STDrumRoadMakai","STGardens") &  sample_type %in% c("SoilDeep","SoilShallow","Sediment","PlantRoot")))
  ST.uni <- get_unifrac(ST_mid)
  ST.ord <- ordinate(ST_mid, "NMDS", ST.uni)
  
  
  #plot
  p <- plot_ordination(ST_mid, ST.ord, type="samples", color = "shore_dist", shape = "sample_type", title= paste("Samples In The Ground, Middle Sites"))
  p <- p  + 
    scale_shape_discrete(solid=T)+
    uniform_gradient_color() +
    theme(title = element_text(size = 16, face = "bold"), axis.text=element_text(size=12),legend.text = element_text(size = 20))+
    geom_point(size = 3)+
    coord_fixed()
  print(p)
  ggsave("outputs/figures/middle_sites_nmds.png", width = 10, height = 10)

  rm(ST_mid)
  

```

### Merging: Summing OTUs at family level for export/heatmaps
Summing OTUs at the family level is recommended for producing readable heatmaps.
First, transform the otu abundance to relative abundance, then sum. 

```{r famMerge}
# sum at family level
 ST_famglom <- speedyseq::tax_glom(ST, "family")
# 
# # check
 ntaxa(ST)
 ntaxa(ST_famglom)

 ST_fam_roots <- subset_samples(ST_famglom, sample_type == "PlantRoot")
 ST_fam_roots <- prune_taxa(names(sort(taxa_sums(ST_fam_roots),TRUE)[1:30]), ST_fam_roots)
 plot_heatmap(ST_fam_roots, sample.label="transect_name")
  
 ntaxa(ST_fam_roots) 


```

### Export drosophila samples
```{r}
ST_dros  <- subset_samples(ST, sample_type == "Drosophila" )
  ST.uni.dros <- get_unifrac(ST_dros) %>% as.matrix() %>% as.data.frame()
  
  write.csv(ST_dros@otu_table,"outputs/drosophila/ST_drosophila_esv_table.csv")
  write.csv(ST_dros@sam_data, "outputs/drosophila/ST_drosophila_sample_table.csv")
  write.csv(ST_dros@tax_table, "outputs/drosophila/ST_drosophila_taxonomy_table.csv")
  write.csv(ST.uni.dros, "outputs/drosophila/ST_drosophila_weighted_unifrac.csv")
  
```



### Mantel tests

```{r}
sample_types <- unique(ST@sam_data$sample_type)

mantel_outputs <- data.frame(SampleType = sample_types, Mantel_R = NA, Mantel_Significance = NA)

for(i in seq_along(sample_types)){
  # subset by sample type
  ST_sub <- subset_samples(ST, sample_type == sample_types[[i]])
  ST.uni <- get_unifrac(ST_sub)
  
  # distance matrix of shore_dist
  shore_dists  <- ST_sub@sam_data$shore_dist
  d.shore_dist <-dist(shore_dists, method = "euclidean")  
  
  # mantel
  uni_shore_dist <- mantel(ST.uni, d.shore_dist, method = "spearman", permutations = 9999, na.rm = T)
  mantel_outputs[i,"Mantel_R"]            <- uni_shore_dist$statistic
  mantel_outputs[i,"Mantel_Significance"] <- uni_shore_dist$signif
  }

mantel_outputs
write.csv(mantel_outputs, "outputs/mantel_outputs.csv")

```


### Heatmaps

```{r heatmaps}
# TODO figure out how to run heatmaps without crashing R. 
#speedyseq::plot_heatmap(test,method = "NMDS", distance = "bray", sample.label =  "habitat", taxa.label = "family")
```

